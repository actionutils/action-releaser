name: SLSA Compliant GitHub Action Release

# This workflow creates a SLSA-compliant release for GitHub Actions
# It's designed as a reusable workflow that can be called from other workflows
# It enforces releases only through labeled PRs (bump:patch, bump:minor, bump:major)
on:
  workflow_call:
    inputs:
      branch:
        description: 'The working branch'
        required: false
        default: 'main'
        type: string
      rekor-log-public:
        description: 'Allow repository name to be logged in public Rekor transparency log'
        required: false
        type: boolean
        default: true
    secrets:
      github-token:
        description: 'GitHub token with appropriate permissions'
        required: true
    outputs:
      tag_name:
        description: 'The tag name created or used for this release'
        value: ${{ jobs.version.outputs.tag_name }}
      version:
        description: 'The version number without "v" prefix'
        value: ${{ jobs.version.outputs.version }}
      release_url:
        description: 'URL of the created GitHub release'
        value: ${{ jobs.release.outputs.release_url }}

jobs:
  # Version management and tag creation job
  version:
    runs-on: ubuntu-latest
    permissions:
      id-token: write # Enable OIDC
      contents: write # Tag updates
      pull-requests: write # Post comment
    outputs:
      tag_name: ${{ steps.tag.outputs.value }}
      version: ${{ steps.extract-version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ inputs.branch }}

      # Set up signed tag configuration
      - uses: chainguard-dev/actions/setup-gitsign@main
      - run: git config --global tag.gpgSign true

      # Bump version based on PR labels (bump:major,bump:minor,bump:patch)
      - id: bumpr
        uses: haya14busa/action-bumpr@v1.11.3

      # Update corresponding major and minor tags
      - uses: haya14busa/action-update-semver@v1.3.0
        if: steps.bumpr.outputs.skip != 'true'
        with:
          tag: ${{ steps.bumpr.outputs.next_version }}

      # Get tag name from bumpr output only
      - id: tag
        run: |
          if [[ "${{ steps.bumpr.outputs.skip }}" == "true" ]]; then
            echo "value=" >> $GITHUB_OUTPUT
            echo "No version bump label found, skipping release."
          else
            TAG="${{ steps.bumpr.outputs.next_version }}"
            echo "value=${TAG}" >> $GITHUB_OUTPUT
            echo "Next version: ${TAG}"
          fi

      # Extract version number without "v" prefix (v1.2.3 â†’ 1.2.3)
      - id: extract-version
        if: steps.tag.outputs.value != ''
        run: |
          TAG=${{ steps.tag.outputs.value }}
          VERSION=${TAG#refs/tags/v}
          VERSION=${VERSION#v}
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Extracted version: ${VERSION}"

  # Prepare information for SLSA provenance
  prepare-slsa:
    needs: [version]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    outputs:
      commit_sha: ${{ steps.save-info.outputs.commit_sha }}
      tag_name: ${{ steps.save-info.outputs.tag_name }}
      base64-subjects: ${{ steps.generate-subjects.outputs.base64-subjects }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      # Save commit info for SLSA provenance
      - name: Save commit info
        id: save-info
        run: |
          COMMIT_SHA="${{ github.sha }}"
          TAG="${{ needs.version.outputs.tag_name }}"
          TAG_NAME="${TAG#refs/tags/}"

          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Using commit: $COMMIT_SHA with tag: $TAG_NAME for provenance"

      # Generate action-identity.json file for SLSA verification
      - name: Generate action identity file
        id: generate-metadata
        run: |
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Create action-identity.json file
          cat > action-identity.json << EOF
          {
            "name": "$REPO_NAME",
            "version": "${{ needs.version.outputs.tag_name }}",
            "timestamp": "$TIMESTAMP",
            "description": "This file contains identity information about this GitHub Action release. It can be verified with the action-identity.intoto.jsonl file to confirm the authenticity and build source of this action.",
            "git": {
              "commit": "${{ github.sha }}",
              "tag": "${{ needs.version.outputs.tag_name }}",
              "repository": "https://github.com/$GITHUB_REPOSITORY"
            }
          }
          EOF

          echo "Generated action-identity.json"

      # Create temporary directory for archives
      - name: Create temporary directory
        id: tempdir-archives
        run: |
          # Create temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "dir=$TEMP_DIR" >> $GITHUB_OUTPUT
          echo "Created temporary directory for archives: $TEMP_DIR"

      # Download and calculate checksums for source archives
      - name: Generate subjects
        id: generate-subjects
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.version.outputs.tag_name }}"
          TEMP_DIR="${{ steps.tempdir-archives.outputs.dir }}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          
          # Download zip and tar.gz archives using gh CLI
          echo "Downloading source archives for tag $TAG_NAME..."
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --archive=zip --dir "$TEMP_DIR"
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --archive=tar.gz --dir "$TEMP_DIR"
          
          # List downloaded files
          echo "Downloaded archives:"
          ls -la "$TEMP_DIR"
          
          # Get filenames
          ZIP_FILE=$(find "$TEMP_DIR" -name "*.zip")
          TAR_FILE=$(find "$TEMP_DIR" -name "*.tar.gz")
          
          # Calculate checksums
          ZIP_CHECKSUM=$(sha256sum "$ZIP_FILE" | awk '{print $1}')
          TAR_CHECKSUM=$(sha256sum "$TAR_FILE" | awk '{print $1}')
          
          # Get just the filenames without path
          ZIP_FILENAME=$(basename "$ZIP_FILE")
          TAR_FILENAME=$(basename "$TAR_FILE")
          
          echo "ZIP checksum ($ZIP_FILENAME): $ZIP_CHECKSUM"
          echo "TAR checksum ($TAR_FILENAME): $TAR_CHECKSUM"
          
          # Create subjects file with action-identity.json and source archives
          cat > subjects.txt << EOF
          $(sha256sum action-identity.json)
          $ZIP_CHECKSUM  $ZIP_FILENAME
          $TAR_CHECKSUM  $TAR_FILENAME
          EOF
          
          echo "Created subjects file with the following entries:"
          cat subjects.txt
          
          # base64 encode the subjects file
          echo "base64-subjects=$(cat subjects.txt | base64 -w0)" >> $GITHUB_OUTPUT
          
      # Clean up temporary archives directory
      - name: Cleanup archives
        if: always()
        run: |
          TEMP_DIR="${{ steps.tempdir-archives.outputs.dir }}"
          if [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
            echo "Temporary archives directory cleaned up: $TEMP_DIR"
          fi

      # Upload action-identity.json as an artifact to share between jobs
      - name: Upload action identity artifact
        uses: actions/upload-artifact@v4
        with:
          name: action-identity-json
          path: action-identity.json
          retention-days: 1


  # Generate SLSA provenance using reusable workflow
  generate-provenance:
    needs: [version, prepare-slsa]
    if: needs.version.outputs.tag_name != ''
    permissions:
      id-token: write    # Required for SLSA provenance generation
      contents: write    # Required for attestations
      actions: read      # Required to access workflow information
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@v2.1.0
    with:
      base64-subjects: ${{ needs.prepare-slsa.outputs.base64-subjects }}
      upload-assets: true
      upload-tag-name: ${{ needs.version.outputs.tag_name }}
      draft-release: true

  # Create GitHub Release job
  release:
    needs: [version, generate-provenance, prepare-slsa]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: write # Required for release creation
    outputs:
      release_url: ${{ steps.create_release.outputs.release_url }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ needs.version.outputs.tag_name }}

      # Download the artifacts from previous jobs

      - name: Download action-identity.json
        uses: actions/download-artifact@v4
        with:
          name: action-identity-json

      # Update existing draft release
      - name: Update GitHub Release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"

          # Upload artifacts to the release
          gh release upload "$TAG_NAME" action-identity.json --clobber

          # Update the existing draft release
          RELEASE_URL=$(gh release edit "$TAG_NAME" \
            --title "Release $TAG_NAME" \
            --notes "$(gh release view "$TAG_NAME" --json body -q .body || echo "")" \
            --draft=false)

          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "Release URL: $RELEASE_URL"

  # Verify the release using SLSA verifier
  verify-release:
    needs: [release, prepare-slsa]
    if: needs.version.outputs.tag_name != ''
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to read release artifacts
    steps:
      - name: Install SLSA verifier
        uses: slsa-framework/slsa-verifier/actions/installer@v2.7.0

      - name: Create temporary directory
        id: tempdir
        run: |
          # Create temporary directory
          TEMP_DIR=$(mktemp -d)
          echo "dir=$TEMP_DIR" >> $GITHUB_OUTPUT
          echo "Created temporary directory: $TEMP_DIR"

      - name: Download files for verification
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"

          # Download the specific attestation file, action-identity.json, and archives
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --pattern "multiple.intoto.jsonl" --dir "$TEMP_DIR"
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --pattern "action-identity.json" --dir "$TEMP_DIR"
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --archive=zip --dir "$TEMP_DIR"
          gh release download "$TAG_NAME" --repo "$GITHUB_REPOSITORY" --archive=tar.gz --dir "$TEMP_DIR"

          echo "Downloaded files to: $TEMP_DIR"
          ls -la "$TEMP_DIR"

      - name: Verify provenance
        env:
          GITHUB_TOKEN: ${{ secrets.github-token }}
        run: |
          TAG_NAME="${{ needs.prepare-slsa.outputs.tag_name }}"
          REPO_NAME="${GITHUB_REPOSITORY}"
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"

          # Use the specific attestation file and identity file
          ATTESTATION_FILE="$TEMP_DIR/multiple.intoto.jsonl"
          IDENTITY_FILE="$TEMP_DIR/action-identity.json"

          if [ -z "$ATTESTATION_FILE" ]; then
            echo "Error: No attestation file found"
            exit 1
          fi

          if [ -z "$IDENTITY_FILE" ]; then
            echo "Error: No action-identity.json file found"
            exit 1
          fi

          echo "Verifying provenance for $ATTESTATION_FILE with all artifacts"
          
          # Find all artifact files
          ZIP_FILE=$(find "$TEMP_DIR" -name "*.zip")
          TAR_FILE=$(find "$TEMP_DIR" -name "*.tar.gz")
          
          echo "Found artifacts:"
          echo "- Identity file: $IDENTITY_FILE"
          echo "- ZIP file: $ZIP_FILE"
          echo "- TAR file: $TAR_FILE"

          # Verify the provenance for all artifacts
          slsa-verifier verify-artifact \
            --provenance-path "$ATTESTATION_FILE" \
            --source-uri "github.com/$REPO_NAME" \
            --source-branch "${{ inputs.branch }}" \
            "$IDENTITY_FILE" "$ZIP_FILE" "$TAR_FILE"

          echo "âœ… Provenance verification successful!"

      - name: Print provenance
        run: |
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"
          ATTESTATION_FILE="$TEMP_DIR/multiple.intoto.jsonl"
          IDENTITY_FILE="$TEMP_DIR/action-identity.json"
          REPO_NAME="${GITHUB_REPOSITORY}"

          # Find all artifact files
          ZIP_FILE=$(find "$TEMP_DIR" -name "*.zip")
          TAR_FILE=$(find "$TEMP_DIR" -name "*.tar.gz")
          
          echo "Printing provenance information for all artifacts:"
          slsa-verifier verify-artifact \
            --provenance-path "$ATTESTATION_FILE" \
            --source-uri "github.com/$REPO_NAME" \
            --source-branch "${{ inputs.branch }}" \
            --print-provenance \
            "$IDENTITY_FILE" "$ZIP_FILE" "$TAR_FILE" | jq .

      - name: Cleanup
        if: always()
        run: |
          # Clean up temporary directory
          TEMP_DIR="${{ steps.tempdir.outputs.dir }}"
          if [ -d "$TEMP_DIR" ]; then
            rm -rf "$TEMP_DIR"
            echo "Temporary directory cleaned up: $TEMP_DIR"
          fi
